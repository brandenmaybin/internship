---
title: "Clutch Work"
author: "Othon Hamill"
date: "October 24, 2018"
output: word_document
---

```{r}
#########################TO DO LIST############################
#How are we going to deal with returns hit into the net? 

#We need to take out possible tieBreaks since they mess with Data

#We have the Data properly corrected for the set set/game Score corrections, but not for any possible match/set Score issues 
```

```{r}
#call our necessary libraries
library(alr3)
library(MASS)
library(dplyr)
library(future.apply)
library(furrr)
library(sass)
library(gt)
library(tictoc)
library(openxlsx)
```

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Functions~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Set Score Corrector, for those situations where the set Score doesn't get set back to 0-0 after a set is won
```{r}
SetScoreCorrector<-function(Data){
  N<-dim(Data)[1]
  Errors<-rep(0,times=N)
  
  #Here's our work for a win on the players side not being counted correctly
    for (i in 1:N){
        Errors[i]<- (Data$PlayerGames[i] >= 6 & Data$OppGames[i] < 5)
    }
  
    #here we correct the game/set Scores. We make the assumption our Data has the sets correct
    Data$PlayerGames<-Data$PlayerGames-Errors*(6)
  
  #here's our work for when  
    
    return(Data)
}
```



Situational Weights adds an additional column which gives a weight Score for each point
40-00 gets a .3 multiplier, 40-15 a .7, 40-30 a 1.0, Deuce a 2x
4-4 and 5-5 get a x1.5 multiplier
Set Points get x2
Second Set Match Points get a x3 Multiplier
Third Set Match Points get a x3 Multiplier

5-4, 4-5, 6-5 and 5-6 gets a +1


```{r}
SituationalWeights<-function(Data){
  N<-dim(Data)[1]
  Multiplier<-rep(0,times=N)
  
  #Game Points by Score weight
  for (i in 1:N){
    if(Data$PlayerPoints[i] == 0 & Data$OppPoints[i] == 3){Multiplier[i]<-.3}
    if(Data$OppPoints[i] == 0 & Data$PlayerPoints[i] == 3){Multiplier[i]<-.3}
    if(Data$PlayerPoints[i] == 1 & Data$OppPoints[i] == 3){Multiplier[i]<-.7}
    if(Data$OppPoints[i] == 1 & Data$PlayerPoints[i] == 3){Multiplier[i]<-.7}
    if(Data$PlayerPoints[i] == 2 & Data$OppPoints[i] == 3){Multiplier[i]<-1}
    if(Data$OppPoints[i] == 2 & Data$PlayerPoints[i] == 3){Multiplier[i]<-1}
    if(Data$PlayerPoints[i] == 3 & Data$OppPoints[i] == 3){Multiplier[i]<-2}
  }
  
  #Game points under duress at 4-4 or 5-5 set Score. High Pressure already keeps only game points
  for (i in 1:N){
    if(Data$PlayerGames[i] == 4 & Data$OppGames[i] == 4){Multiplier[i]<-Multiplier[i]*1.5}
    if(Data$OppGames[i] == 5 & Data$PlayerGames[i] == 5){Multiplier[i]<-Multiplier[i]*1.5}
  }

  #Set Points, 1st set about to be won by either or second about to be won by the loser of the first set
  for (i in 1:N){
    #Opp about to win the set
    if(((Data$PlayerSets[i] == 0 & Data$OppSets[i] == 0) | (Data$PlayerSets[i] == 1 & Data$OppSets[i] == 0)) & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 6) {Multiplier[i]<-Multiplier[i]*2+1}
    if(((Data$PlayerSets[i] == 0 & Data$OppSets[i] == 0) | (Data$PlayerSets[i] == 1 & Data$OppSets[i] == 0)) & Data$PlayerGames[i] == 4 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*2+1}
    if(((Data$PlayerSets[i] == 0 & Data$OppSets[i] == 0) | (Data$PlayerSets[i] == 1 & Data$OppSets[i] == 0)) & Data$PlayerGames[i] == 3 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*2}
    if(((Data$PlayerSets[i] == 0 & Data$OppSets[i] == 0) | (Data$PlayerSets[i] == 1 & Data$OppSets[i] == 0)) & Data$PlayerGames[i] == 2 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*2}
    if(((Data$PlayerSets[i] == 0 & Data$OppSets[i] == 0) | (Data$PlayerSets[i] == 1 & Data$OppSets[i] == 0)) & Data$PlayerGames[i] == 1 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*2}
    if(((Data$PlayerSets[i] == 0 & Data$OppSets[i] == 0) | (Data$PlayerSets[i] == 1 & Data$OppSets[i] == 0)) & Data$PlayerGames[i] == 0 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*2}
    #player about to win the set
    if(((Data$PlayerSets[i] == 0 & Data$OppSets[i] == 0) | (Data$PlayerSets[i] == 0 & Data$OppSets[i] == 1)) & Data$PlayerGames[i] == 6 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*2+1}
    if(((Data$PlayerSets[i] == 0 & Data$OppSets[i] == 0) | (Data$PlayerSets[i] == 0 & Data$OppSets[i] == 1)) & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 4) {Multiplier[i]<-Multiplier[i]*2+1}
    if(((Data$PlayerSets[i] == 0 & Data$OppSets[i] == 0) | (Data$PlayerSets[i] == 0 & Data$OppSets[i] == 1)) & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 3) {Multiplier[i]<-Multiplier[i]*2}
    if(((Data$PlayerSets[i] == 0 & Data$OppSets[i] == 0) | (Data$PlayerSets[i] == 0 & Data$OppSets[i] == 1)) & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 2) {Multiplier[i]<-Multiplier[i]*2}
    if(((Data$PlayerSets[i] == 0 & Data$OppSets[i] == 0) | (Data$PlayerSets[i] == 0 & Data$OppSets[i] == 1)) & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 1) {Multiplier[i]<-Multiplier[i]*2}
    if(((Data$PlayerSets[i] == 0 & Data$OppSets[i] == 0) | (Data$PlayerSets[i] == 0 & Data$OppSets[i] == 1)) & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 0) {Multiplier[i]<-Multiplier[i]*2}
  }
  
  #Match Points in the second set
  for(i in 1:N){
    #player about to win
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 0 & Data$PlayerGames[i] == 6 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*3+1}
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 0 & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 4) {Multiplier[i]<-Multiplier[i]*3+1}
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 0 & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 3) {Multiplier[i]<-Multiplier[i]*3}
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 0 & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 2) {Multiplier[i]<-Multiplier[i]*3}
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 0 & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 1) {Multiplier[i]<-Multiplier[i]*3}
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 0 & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 0) {Multiplier[i]<-Multiplier[i]*3}
    #Opponent about to win
    if(Data$PlayerSets[i] == 0 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 6) {Multiplier[i]<-Multiplier[i]*3+1}
    if(Data$PlayerSets[i] == 0 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 4 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*3+1}
    if(Data$PlayerSets[i] == 0 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 3 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*3}
    if(Data$PlayerSets[i] == 0 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 2 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*3}
    if(Data$PlayerSets[i] == 0 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 1 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*3}
    if(Data$PlayerSets[i] == 0 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 0 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*3}
  }
  
  #Match Points in the Third set
  for(i in 1:N){
    #player about to win
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 6 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*5+1}
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 4) {Multiplier[i]<-Multiplier[i]*5+1}
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 3) {Multiplier[i]<-Multiplier[i]*5}
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 2) {Multiplier[i]<-Multiplier[i]*5}
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 1) {Multiplier[i]<-Multiplier[i]*5}
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 0) {Multiplier[i]<-Multiplier[i]*5}
    #Opponent about to win
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 5 & Data$OppGames[i] == 6) {Multiplier[i]<-Multiplier[i]*5+1}
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 4 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*5+1}
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 3 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*5}
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 2 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*5}
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 1 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*5}
    if(Data$PlayerSets[i] == 1 & Data$OppSets[i] == 1 & Data$PlayerGames[i] == 0 & Data$OppGames[i] == 5) {Multiplier[i]<-Multiplier[i]*5}
  }
  
  return(Multiplier)
}

```



PServingOnly function filters out Opponents, leaving just BYU serving
```{r}
PServingOnly<-function(RawData){
  Joint<-filter(RawData,RawData$Server=="P")
}
```

HighPressure function keeps only possible Clutch points (a Break or Hold point)
```{r}
HighPressure<-function(RawData){
  #just Clutch points, no sorting for Server
HP<-rbind(
    RawData[(RawData$PlayerPoints == 0 & RawData$OppPoints == 3),],
    RawData[(RawData$PlayerPoints == 1 & RawData$OppPoints == 3),],
    RawData[(RawData$PlayerPoints == 2 & RawData$OppPoints == 3),],
    RawData[(RawData$PlayerPoints == 3 & RawData$OppPoints == 3),],
    RawData[(RawData$PlayerPoints == 3 & RawData$OppPoints == 2),],
    RawData[(RawData$PlayerPoints == 3 & RawData$OppPoints == 1),],
    RawData[(RawData$PlayerPoints == 3 & RawData$OppPoints == 0),])
  return(HP)
}
```

LowPressure function keeps everything but Clutch points
```{r}
LowPressure<-function(RawData){
  #just Clutch points, no sorting for Server
LP<-RawData[(RawData$PlayerPoints != 3 & RawData$OppPoints != 3),]
  return(LP)
}
```

Serving Scoring function
```{r}
ServingScore<-function(Dataset, W=c(1,-1,0)){
  Clutch<-rbind(filter(Dataset,Dataset$PointWinner=="P" & Dataset$PointLength=="S" & Dataset$Result %in% c("W","F") & Dataset$Server=="P"), filter(Dataset, Dataset$Result=="A" & Dataset$Server=="P"))
  Choke<-rbind(filter(Dataset,Dataset$PointWinner=="O" & Dataset$PointLength=="S" & Dataset$Result %in% c("W","F") & Dataset$Server=="P"), filter(Dataset, Dataset$Result=="D" & Dataset$Server=="P"))
  Null<-rbind(filter(Dataset, Dataset$ServeResult %in% c("F","S") & Dataset$PointLength %in% c("M","L") & Dataset$Server=="P"))
  #we add an if here to catch when we run the LPcolum through serving, since the situational Weights of low pressure situations are 0. Here, if we find all the values are 0 we just use the dimensions in the calculation
  if(sum(Clutch$SituationalWeight)+sum(Choke$SituationalWeight)+sum(Null$SituationalWeight) == 0){
    Score<-dim(Clutch)[1]*W[1]+dim(Choke)[1]*W[2]+dim(Null)[1]*W[3]
  }
  else{
    Score<-c(sum(Clutch$SituationalWeight)*W[1]+sum(Choke$SituationalWeight)*W[2]+sum(Null$SituationalWeight)*W[3])
  }
  
  N<-dim(rbind(Clutch,Choke,Null))[1]
  
  Ans<-list(Score,N)
  
  return(Ans)
}
```

Play Scoring function
```{r}
PlayScore<-function(Dataset, W=c(1,-1,0)){
  Clutch<-filter(Dataset,Dataset$PointWinner=="P" & Dataset$Result %in% c("W","F"))
  Choke<-filter(Dataset,Dataset$PointWinner=="O" & Dataset$Result == "U")
  Null<-rbind(filter(Dataset,Dataset$PointWinner=="P" & Dataset$Result == "U"), filter(Dataset,Dataset$PointWinner=="O" & Dataset$Result %in% c("W","F")))
  #we can add in modifiers if we so desire here
  Score<-c(sum(Clutch$SituationalWeight)*W[1]+sum(Choke$SituationalWeight)*W[2]+sum(Null$SituationalWeight)*W[3])
  
  N<-dim(rbind(Clutch,Choke,Null))[1]
  
  Ans<-list(Score,N)
  
  return(Ans)
}
```

Serving + Play Clutch Score
```{r}
ClutchScore<-function(Dataset){
  Score<-PlayScore(Dataset)[[1]]+ServingScore(Dataset)[[1]]
  N<-PlayScore(Dataset)[[2]]+ServingScore(Dataset)[[2]]
  Ans<-list(Score,N)
  return(Ans)
}
```


Low Pressure Column (No game points of any kind)
```{r}
LPcolumn<-function(Dataset){
  LPData<-LowPressure(Dataset)
  
  LPServingScore<-ServingScore(LPData)[[1]]
  LPPlayScore<-PlayScore(LPData)[[1]]
  LPClutchScore<-ClutchScore(LPData)[[1]]
  LPColumn<-c(LPServingScore,LPPlayScore,LPClutchScore)
  
  LPServingN<-ServingScore(LPData)[[2]]
  LPPlayN<-PlayScore(LPData)[[2]]
  LPClutchN<-ClutchScore(LPData)[[2]]
  LPN<-c(LPServingN,LPPlayN,LPClutchN)
  
  Ans<-list(LPColumn,LPN)
  
  return(Ans)
}
```


BYU Hold Point Calculating function
```{r}
BYUHoldColumn<-function(Dataset){
  #build the BYU Holding Data frame including the deuce points
  BYUHolddf<-rbind(
    Dataset[(Dataset$PlayerPoints == 3 & Dataset$OppPoints == 3) & Dataset$Server== "P",],
    Dataset[(Dataset$PlayerPoints == 3 & Dataset$OppPoints == 2) & Dataset$Server== "P",],
    Dataset[(Dataset$PlayerPoints == 3 & Dataset$OppPoints == 1) & Dataset$Server== "P",],
    Dataset[(Dataset$PlayerPoints == 3 & Dataset$OppPoints == 0) & Dataset$Server== "P",])
  BYUHoldServingScore<-ServingScore(BYUHolddf)
  BYUHoldPlayScore<-PlayScore(BYUHolddf)
  BYUHoldClutchScore<-ClutchScore(BYUHolddf)
  BYUHoldScores<-c(BYUHoldServingScore[[1]],BYUHoldPlayScore[[1]],BYUHoldClutchScore[[1]])
  N<-c(BYUHoldServingScore[[2]],BYUHoldPlayScore[[2]],BYUHoldClutchScore[[2]])
  Ans<-list(BYUHoldScores,N)
  return(Ans)
}
```

BYU being broken Point Calculating function
```{r}
BYUBreakColumn<-function(Dataset){
  #build the BYU to be broken Data frame including the deuce points
  BYUBreakdf<-rbind(
    Dataset[(Dataset$PlayerPoints == 3 & Dataset$OppPoints == 3) & Dataset$Server== "P",],
    Dataset[(Dataset$PlayerPoints == 2 & Dataset$OppPoints == 3) & Dataset$Server== "P",],
    Dataset[(Dataset$PlayerPoints == 1 & Dataset$OppPoints == 3) & Dataset$Server== "P",],
    Dataset[(Dataset$PlayerPoints == 0 & Dataset$OppPoints == 3) & Dataset$Server== "P",])
  BYUBreakServingScore<-ServingScore(BYUBreakdf)
  BYUBreakPlayScore<-PlayScore(BYUBreakdf)
  BYUBreakClutchScore<-ClutchScore(BYUBreakdf)
  BYUBreakScores<-c(BYUBreakServingScore[[1]],BYUBreakPlayScore[[1]],BYUBreakClutchScore[[1]])
  N<-c(BYUBreakServingScore[[2]],BYUBreakPlayScore[[2]],BYUBreakClutchScore[[2]])
  Ans<-list(BYUBreakScores,N)
  return(Ans)
}
```

Opp Hold Point Calculating function
```{r}
OppHoldColumn<-function(Dataset){
  #build the Opp Holding Data frame including the deuce points
  OppHolddf<-rbind(
    Dataset[(Dataset$PlayerPoints == 3 & Dataset$OppPoints == 3) & Dataset$Server== "O",],
    Dataset[(Dataset$PlayerPoints == 2 & Dataset$OppPoints == 3) & Dataset$Server== "O",],
    Dataset[(Dataset$PlayerPoints == 1 & Dataset$OppPoints == 3) & Dataset$Server== "O",],
    Dataset[(Dataset$PlayerPoints == 0 & Dataset$OppPoints == 3) & Dataset$Server== "O",])
  OppHoldPlayScore<-PlayScore(OppHolddf)
  OppHoldClutchScore<-ClutchScore(OppHolddf)
  OppHoldScores<-c(OppHoldPlayScore[[1]],OppHoldClutchScore[[1]])
  N<-c(OppHoldPlayScore[[2]],OppHoldClutchScore[[2]])
  Ans<-list(OppHoldScores,N)
  return(Ans)
}
```

Opp being broken Point Calculating function
```{r}
OppBreakColumn<-function(Dataset){
  #build the Opp Breaking Data frame including the deuce points
  OppBreakdf<-rbind(
    Dataset[(Dataset$PlayerPoints == 3 & Dataset$OppPoints == 3) & Dataset$Server== "O",],
    Dataset[(Dataset$PlayerPoints == 3 & Dataset$OppPoints == 2) & Dataset$Server== "O",],
    Dataset[(Dataset$PlayerPoints == 3 & Dataset$OppPoints == 1) & Dataset$Server== "O",],
    Dataset[(Dataset$PlayerPoints == 3 & Dataset$OppPoints == 0) & Dataset$Server== "O",])
  OppBreakPlayScore<-PlayScore(OppBreakdf)
  OppBreakClutchScore<-ClutchScore(OppBreakdf)
  OppBreakScores<-c(OppBreakPlayScore[[1]],OppBreakClutchScore[[1]])
  N<-c(OppBreakPlayScore[[2]],OppBreakClutchScore[[2]])
  Ans<-list(OppBreakScores,N)
  return(Ans)
}
```

Raw Combo makes the Raw combo column in the Clutch table. It should return a vector of 3, each with 3 elements
```{r}
Rawcombo<-function(Dataset){
  #read in the four pressure column situations
  BYUHold<-BYUHoldColumn(Dataset)[[1]]
  BYUBreak<-BYUBreakColumn(Dataset)[[1]]
  OppHold<-OppHoldColumn(Dataset)[[1]]
  OppBreak<-OppBreakColumn(Dataset)[[1]]
  
  #initialize and then fill in Rawcombocolumn
  Rawcombocolumn<-NULL

    Top<-BYUHold[1]+BYUBreak[1]
    Middle<-BYUHold[2]+BYUBreak[2]+OppHold[1]+OppBreak[1]
    Bottom<-BYUHold[3]+BYUBreak[3]+OppHold[2]+OppBreak[2]
  
  RawComboColumn<-c(Top,Middle,Bottom)
  
  NTop<-BYUHoldColumn(Dataset)[[2]][1]+BYUBreakColumn(Dataset)[[2]][1]
  NMiddle<-BYUHoldColumn(Dataset)[[2]][2] + BYUBreakColumn(Dataset)[[2]][2] + OppHoldColumn(Dataset)[[2]][1] + OppBreakColumn(Dataset)[[2]][1]
  NBottom<-BYUHoldColumn(Dataset)[[2]][3] + BYUBreakColumn(Dataset)[[2]][3] + OppHoldColumn(Dataset)[[2]][2] + OppBreakColumn(Dataset)[[2]][2]
  
  RawComboN<-c(NTop, NMiddle, NBottom)
  
  Ans<-list(RawComboColumn, RawComboN)
  
  return(Ans)
}
```

The Weighted combo function takes a Dataset and a weight vector of length 12 it can apply to each combination of OPP/BYU/Hold/Break being Clutch, Choke or neutral. It doesn't account for specific high-stress points, like a match points vs. a Hold point in the first set. 
```{r}
#It's jacked up. This needs some fixing with list being put into serving and play scores
wcombo<-function(Dataset,Weights=c(rep(1,times=12))){
  #read in the four pressure column situations
  BYUHold<-BYUHoldColumn(Dataset)[[1]]
  BYUBreak<-BYUBreakColumn(Dataset)[[1]]
  OppHold<-OppHoldColumn(Dataset)[[1]]
  OppBreak<-OppBreakColumn(Dataset)[[1]]
  
  #initialize and then fill in Rawcombocolumn
  WComboColumn<-NULL
  
    S<-Weights[1]*unlist(BYUHold[1])[1]+Weights[2]*unlist(BYUBreak[1])[1]
    P<-Weights[5]*unlist(BYUHold[1])[2]+Weights[6]*unlist(BYUBreak[1])[2]
    C<-Weights[9]*unlist(BYUHold[1])[3]+Weights[10]*unlist(BYUBreak[1])[3]
    Top<-c(S,P,C)
    
    S<-Weights[1]*unlist(BYUHold[2])[1]+Weights[2]*unlist(BYUBreak[2])[1]+Weights[3]*unlist(OppHold[1])[1]+Weights[4]*unlist(OppBreak[1])[1]
    P<-Weights[5]*unlist(BYUHold[2])[2]+Weights[6]*unlist(BYUBreak[2])[2]+Weights[7]*unlist(OppHold[1])[2]+Weights[8]*unlist(OppBreak[1])[2]
    C<-Weights[9]*unlist(BYUHold[2])[3]+Weights[10]*unlist(BYUBreak[2])[3]+Weights[11]*unlist(OppHold[1])[3]+Weights[12]*unlist(OppBreak[1])[3]
    Middle<-c(S,P,C)
    
    S<-Weights[1]*unlist(BYUHold[3])[1]+Weights[2]*unlist(BYUBreak[3])[1]+Weights[3]*unlist(OppHold[2])[1]+Weights[4]*unlist(OppBreak[2])[1]
    P<-Weights[5]*unlist(BYUHold[3])[2]+Weights[6]*unlist(BYUBreak[3])[2]+Weights[7]*unlist(OppHold[2])[2]+Weights[8]*unlist(OppBreak[2])[2]
    C<-Weights[9]*unlist(BYUHold[3])[3]+Weights[10]*unlist(BYUBreak[3])[3]+Weights[11]*unlist(OppHold[2])[3]+Weights[12]*unlist(OppBreak[2])[3]
    Bottom<-c(S,P,C)
  
  WComboColumn<-list(Top,Middle,Bottom)
  return(WComboColumn)
}
```


fullanalysismatrix calls all our previous functions and turns them into a matrix that looks like our table we have under Clutch analysis
```{r}
FullClutchMatrix<-function(Dataset){
  #Format the Matrix
  MATRIX<-matrix(data=0,nrow=3,ncol = 6)
  rownames(MATRIX)<-c("Clutch Serving Score","Clutch Playing Score", "Overall Clutch Score")
  colnames(MATRIX)<-c("Low Pressure","BYU Hold", "BYU Break", "Opp Hold", "Opp Break", "Combo")
  
  #Make the LP matrix and do the non-Clutch column
  LPDataset<-LPcolumn(Dataset)
  MATRIX[,1]<-round(LPDataset[[1]]/LPDataset[[2]], digits = 3)
  
  #Then the next 4 columns
  HPDataset<-HighPressure(Dataset)
  MATRIX[,2]<-round(BYUHoldColumn(HPDataset)[[1]]/BYUHoldColumn(HPDataset)[[2]], digits = 3)
  MATRIX[,3]<-round(BYUBreakColumn(HPDataset)[[1]]/BYUBreakColumn(HPDataset)[[2]], digits = 3)
  MATRIX[2:3,4]<-round(OppHoldColumn(HPDataset)[[1]]/OppHoldColumn(HPDataset)[[2]], digits = 3)
  MATRIX[2:3,5]<-round(OppBreakColumn(HPDataset)[[1]]/OppHoldColumn(HPDataset)[[2]], digits = 3)
  MATRIX[,6]<-round(Rawcombo(HPDataset)[[1]]/Rawcombo(HPDataset)[[2]], digits = 3)
  MATRIX[1,4:5]<-c(NA,NA)
  MATRIX<-as.data.frame.matrix(MATRIX)
  return(MATRIX)
}
```

FormatData: Does all the formating we need before throwing it in FullMatrix
```{r}
FormatData<-function(RawData,DataType="OldSQL"){
  if(DataType=="NewExcel"){
    JointData<-(cbind(RawData[,c(11,12,14:16,18:24,32)],rep(0,length=dim(RawData)[1])))
  }
  if(DataType=="OldSQL"){
    JointData<-(cbind(RawData[,c(12:13,15:17,19:25,33)],rep(0,length=dim(RawData)[1])))
  }
  colnames(JointData)<-c("PlayerSets","OppSets","PlayerGames","OppGames","Server", "PlayerPoints", "OppPoints", "ServeResult", "ServeLocation", "ReturnLocation", "Result", "PointWinner", "PointLength","SituationalWeight")
  JointData<-SetScoreCorrector(JointData)
  JointData<-as.tbl(JointData)
  JointData$SituationalWeight<-SituationalWeights(JointData)
  return(JointData)
}

```

MaleBoot: THIS TAKES ALMOST 30 MINUTES WHEN SET TO THE FULL APPROPRIATE VALUE OF 1000 REPS
```{r, evaluate=FALSE}
MaleBoot<-function(Data,Reps=250){
  BigBoot<-future_replicate(Reps, FullMatrix(FormatData(Data[sample(1:dim(Data)[1],size=100, replace=TRUE),])))
}
```

FemaleBoot: THIS TAKES ALMOST 30 MINUTES WHEN SET TO THE FULL APPROPRIATE VALUE OF 1000 REPS
```{r,evaluate=FALSE}
FemaleBoot<-function(Data,Reps=250){
  BigBoot<-future_replicate(Reps, FullMatrix(FormatData(Data[sample(1:dim(Data)[1],size=100, replace=TRUE),])))
}
```

This function automatically updates the color scale values for either male or female data
```{r, evaluate=FALSE}
BaseColorVals<-function(Gender){
  
  #reads in the appropriate data for either males or females
  if(Gender=="Female"){
    AllData<-rbind(read.csv("Women's Player Data Files/MJones.csv"),
               read.csv("Women's Player Data Files/AAbramyan.csv"),
               read.csv("Women's Player Data Files/KCusick.csv"),
               read.csv("Women's Player Data Files/PMalykh.csv"),
               read.csv("Women's Player Data Files/SSmith.csv"))
  }
  
  #Makes the Full table
  FData<-FormatData(AllData)
  TabData<-FullMatrix(FData)
  FinTable<-gt(TabData, rownames_to_stub = TRUE)
  
  #THIS IS A MONSTER AND TAKES 6 MINUTES TO RUN AT 250 ITERATIONS, WHICH IS A QUARTER OF THE RECOMMENDED 1000. ONLY RUN ONCE AND DO NOT DELETE UNLESS NECESSARY
  Reps<-25
  ifelse(Gender=="Female",BOOTLICKINMONSTER<-FemaleBoot(AllData, Reps),BOOTLICKINMONSTER<-MaleBoot(AllData, Reps))
  
  #here we take the means and the SD's
  LPBMean<-mean(unlist(BOOTLICKINMONSTER[1,c(1:Reps)]))
  LPBSD<-sd(unlist(BOOTLICKINMONSTER[1,c(1:Reps)]))
  BHBMean<-mean(unlist(BOOTLICKINMONSTER[2,c(1:Reps)]))
  BHBSD<-sd(unlist(BOOTLICKINMONSTER[2,c(1:Reps)]))
  BBBMean<-mean(unlist(BOOTLICKINMONSTER[3,c(1:Reps)]))
  BBBSD<-sd(unlist(BOOTLICKINMONSTER[3,c(1:Reps)]))
  OHBMean<-mean(unlist(BOOTLICKINMONSTER[4,c(1:Reps)])[c(3*(1:(Reps)),3*(1:(Reps))-1)])
  OHBSD<-sd(unlist(BOOTLICKINMONSTER[4,c(1:Reps)]))
  OBBMean<-mean(unlist(BOOTLICKINMONSTER[5,c(1:Reps)])[c(3*(1:(Reps)),3*(1:(Reps))-1)])
  OBBSD<-sd(unlist(BOOTLICKINMONSTER[5,c(1:Reps)]))
  CBMean<-mean(unlist(BOOTLICKINMONSTER[6,c(1:Reps)]))
  CBSD<-sd(unlist(BOOTLICKINMONSTER[6,c(1:Reps)]))
  
  c(3*(1:(Reps)))
  
  #Assigning the values for our domains
  LP<-c(LPBMean+c(-1,1)*LPBSD)
  BH<-c(BHBMean+c(-1,1)*BHBSD)
  BB<-c(BBBMean+c(-1,1)*BBBSD)
  OH<-c(OHBMean+c(-1,1)*OHBSD)
  OB<-c(OBBMean+c(-1,1)*OBBSD)
  C<-c(CBMean+c(-1,1)*CBSD)
  
  ColorDomains<-list(LP, BH, BB, OH, OB, C)
  return(ColorDomains)
}
```


Here we'll create the table after inputting just the RawData
```{r}
ClutchTableMaker<-function(RawData){
  FData<-FormatData(RawData)
  TabData<-FullClutchMatrix(FData)
  
  #Start the gt
  FinTable<-gt(TabData, rownames_to_stub = TRUE)
  
  #add the header, with names varying on whether on not there's multiple people in the table to make
  Names<-unique(RawData$PlayerID)
  
  #for
  
  if (length(Names)==1){
    FinTable <-
      tab_header(data = FinTable,
    title = "Clutch Scoring Table",
    subtitle = paste(Names))
    #subtitle = paste(Names, "data from", min(as.Date(RawData$Date,"%m/%d/%Y")), "to", max(as.Date(RawData$Date,"%m/%d/%Y")))
  }
  
  #Assigning the values for our domains
  LP<-c(-.2,.2)
  BH<-c(-.5,1)
  BB<-c(-.64,1)
  OH<-c(-.5,.3)
  OB<-c(-.5,.3)
  C<-c(-1,1)

  #Coloring the columns in order, using the values we chose earlier for highs and lows
  FinTable<-data_color(FinTable,columns = "Low Pressure", colors = scales::col_numeric(palette = "RdYlGn", domain = LP))
  #FinTable<-data_color(FinTable,columns = "BYU Hold", colors = scales::col_numeric(palette = "RdYlGn", domain = BH))
  #FinTable<-data_color(FinTable,columns = "BYU Break", colors = scales::col_numeric(palette = "RdYlGn", domain = BB))
  #FinTable<-data_color(FinTable,columns = "Opp Hold", colors = scales::col_numeric(palette = "RdYlGn", domain = OH))
  #FinTable<-data_color(FinTable,columns = "Opp Break", colors = scales::col_numeric(palette = "RdYlGn", domain = OB))
  #FinTable<-data_color(FinTable,columns = "Combo", colors = scales::col_numeric(palette = "RdYlGn", domain = C))  
      
  return(FinTable)
}
```



~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~WORKING EXAMPLES~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

~~~~~~~~~~~~~~~~~~~~Now's let's work with the Women's Data already collected~~~~~~~~~~~~~~~~~~~~~~
All the Women's Data Together runs, as well as individual players' data

```{r}
AllData<-rbind(read.csv("Women's Player Data Files/MJones.csv"),
               read.csv("Women's Player Data Files/AAbramyan.csv"),
               read.csv("Women's Player Data Files/KCusick.csv"),
               read.csv("Women's Player Data Files/PMalykh.csv"),
               read.csv("Women's Player Data Files/SSmith.csv"),
               read.csv("Women's Player Data Files/HKaur.csv"))


(AllTable<-ClutchTableMaker(AllData))
(MJones<-ClutchTableMaker(read.csv("Women's Player Data Files/MJones.csv")))
(AAbramyan<-ClutchTableMaker(read.csv("Women's Player Data Files/AAbramyan.csv")))
(KCusick<-ClutchTableMaker(read.csv("Women's Player Data Files/KCusick.csv")))
(PMalykh<-ClutchTableMaker(read.csv("Women's Player Data Files/PMalykh.csv")))
(SSmith<-ClutchTableMaker(read.csv("Women's Player Data Files/SSmith.csv")))
(HKaur<-ClutchTableMaker(read.csv("Women's Player Data Files/HKaur.csv")))
```

RUNNING TO DO LIST:
- FIX MINOR COLORATION ISSUES
- DO THE BOOTSTRAPPING TO EVALUATE EACH PLAYER'S PERFORMANCE